"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useAssistant: () => (/* binding */ experimental_useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/nanoid/non-secure/index.js\");\n/* __next_internal_client_entry_do_not_use__ experimental_useAssistant,useChat,useCompletion auto */ // react/use-chat.ts\n\n\n// shared/utils.ts\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessage = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlData = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessage,\n    assistantControlData\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessage.code]: assistantMessage,\n    [assistantControlData.code]: assistantControlData\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessage.name]: assistantMessage.code,\n    [assistantControlData.name]: assistantControlData.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\n// shared/utils.ts\nvar nanoid = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\nvar COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function* readDataStream(reader, { isAborted } = {}) {\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts2 = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseStreamPart);\n        for (const streamPart of streamParts2){\n            yield streamPart;\n        }\n        if (isAborted == null ? void 0 : isAborted()) {\n            reader.cancel();\n            break;\n        }\n    }\n}\n// shared/parse-complex-response.ts\nasync function parseComplexResponse({ reader, abortControllerRef, update, onFinish, generateId = nanoid, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    const createdAt = getCurrentDate();\n    const prefixMap = {\n        data: []\n    };\n    for await (const { type, value } of readDataStream(reader, {\n        isAborted: ()=>(abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n    })){\n        if (type === \"text\") {\n            if (prefixMap[\"text\"]) {\n                prefixMap[\"text\"] = {\n                    ...prefixMap[\"text\"],\n                    content: (prefixMap[\"text\"].content || \"\") + value\n                };\n            } else {\n                prefixMap[\"text\"] = {\n                    id: generateId(),\n                    role: \"assistant\",\n                    content: value,\n                    createdAt\n                };\n            }\n        }\n        let functionCallMessage = null;\n        if (type === \"function_call\") {\n            prefixMap[\"function_call\"] = {\n                id: generateId(),\n                role: \"assistant\",\n                content: \"\",\n                function_call: value.function_call,\n                name: value.function_call.name,\n                createdAt\n            };\n            functionCallMessage = prefixMap[\"function_call\"];\n        }\n        if (type === \"data\") {\n            prefixMap[\"data\"].push(...value);\n        }\n        const responseMessage = prefixMap[\"text\"];\n        const merged = [\n            functionCallMessage,\n            responseMessage\n        ].filter(Boolean);\n        update(merged, [\n            ...prefixMap[\"data\"]\n        ]);\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// shared/call-api.ts\nasync function callApi({ api, messages, body, credentials, headers, abortController, appendMessage, restoreMessagesOnFailure, onResponse, onUpdate, onFinish, generateId }) {\n    var _a;\n    const response = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n            messages,\n            ...body\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error(await response.text() || \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const reader = response.body.getReader();\n    const isComplexMode = response.headers.get(COMPLEX_HEADER) === \"true\";\n    if (isComplexMode) {\n        return await parseComplexResponse({\n            reader,\n            abortControllerRef: abortController != null ? {\n                current: abortController()\n            } : void 0,\n            update: onUpdate,\n            onFinish (prefixMap) {\n                if (onFinish && prefixMap.text != null) {\n                    onFinish(prefixMap.text);\n                }\n            },\n            generateId\n        });\n    } else {\n        const createdAt = /* @__PURE__ */ new Date();\n        const decode = createChunkDecoder(false);\n        let streamedResponse = \"\";\n        const replyId = generateId();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) {\n                break;\n            }\n            streamedResponse += decode(value);\n            if (streamedResponse.startsWith('{\"function_call\":')) {\n                responseMessage[\"function_call\"] = streamedResponse;\n            } else {\n                responseMessage[\"content\"] = streamedResponse;\n            }\n            appendMessage({\n                ...responseMessage\n            });\n            if ((abortController == null ? void 0 : abortController()) === null) {\n                reader.cancel();\n                break;\n            }\n        }\n        if (streamedResponse.startsWith('{\"function_call\":')) {\n            const parsedFunctionCall = JSON.parse(streamedResponse).function_call;\n            responseMessage[\"function_call\"] = parsedFunctionCall;\n            appendMessage({\n                ...responseMessage\n            });\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n}\n// shared/process-chat-stream.ts\nasync function processChatStream({ getStreamedResponse: getStreamedResponse2, experimental_onFunctionCall, updateChatRequest, getCurrentMessages }) {\n    while(true){\n        const messagesAndDataOrJustMessage = await getStreamedResponse2();\n        if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages){\n                if (message.function_call === void 0 || typeof message.function_call === \"string\") {\n                    continue;\n                }\n                hasFollowingResponse = true;\n                if (experimental_onFunctionCall) {\n                    const functionCall = message.function_call;\n                    const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                    if (functionCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(functionCallResponse);\n                }\n            }\n            if (!hasFollowingResponse) {\n                break;\n            }\n        } else {\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if (streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") {\n                break;\n            }\n            if (experimental_onFunctionCall) {\n                const functionCall = streamedResponseMessage.function_call;\n                const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                if (functionCallResponse === void 0) break;\n                updateChatRequest(functionCallResponse);\n            }\n        }\n    }\n}\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, generateId, onFinish, onResponse, sendExtraMessageFields)=>{\n    var _a, _b;\n    const previousMessages = messagesRef.current;\n    mutate(chatRequest.messages, false);\n    const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(({ role, content, name, function_call })=>({\n            role,\n            content,\n            ...name !== void 0 && {\n                name\n            },\n            ...function_call !== void 0 && {\n                function_call\n            }\n        }));\n    if (typeof api !== \"string\") {\n        const replyId = generateId();\n        const createdAt = /* @__PURE__ */ new Date();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        async function readRow(promise) {\n            const { content, ui, next } = await promise;\n            responseMessage[\"content\"] = content;\n            responseMessage[\"ui\"] = await ui;\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ], false);\n            if (next) {\n                await readRow(next);\n            }\n        }\n        try {\n            const promise = api({\n                messages: constructedMessagesPayload,\n                data: chatRequest.data\n            });\n            await readRow(promise);\n        } catch (e) {\n            mutate(previousMessages, false);\n            throw e;\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n    return await callApi({\n        api,\n        messages: constructedMessagesPayload,\n        body: {\n            data: chatRequest.data,\n            ...extraMetadataRef.current.body,\n            ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n            ...chatRequest.functions !== void 0 && {\n                functions: chatRequest.functions\n            },\n            ...chatRequest.function_call !== void 0 && {\n                function_call: chatRequest.function_call\n            }\n        },\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n            ...extraMetadataRef.current.headers,\n            ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n        },\n        abortController: ()=>abortControllerRef.current,\n        appendMessage (message) {\n            mutate([\n                ...chatRequest.messages,\n                message\n            ], false);\n        },\n        restoreMessagesOnFailure () {\n            mutate(previousMessages, false);\n        },\n        onResponse,\n        onUpdate (merged, data) {\n            mutate([\n                ...chatRequest.messages,\n                ...merged\n            ], false);\n            mutateStreamData([\n                ...existingData || [],\n                ...data || []\n            ], false);\n        },\n        onFinish,\n        generateId\n    });\n};\nfunction useChat({ api = \"/api/chat\", id, initialMessages, initialInput = \"\", sendExtraMessageFields, experimental_onFunctionCall, onResponse, onFinish, onError, credentials, headers, body, generateId = nanoid } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const chatId = id || hookId;\n    const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        chatId\n    ], null, {\n        fallbackData: initialMessages != null ? initialMessages : initialMessagesFallback\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatId,\n        \"streamData\"\n    ], null);\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            await processChatStream({\n                getStreamedResponse: ()=>getStreamedResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, generateId, onFinish, onResponse, sendExtraMessageFields),\n                experimental_onFunctionCall,\n                updateChatRequest: (chatRequestParam)=>{\n                    chatRequest = chatRequestParam;\n                },\n                getCurrentMessages: ()=>messagesRef.current\n            });\n            abortControllerRef.current = null;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamData,\n        sendExtraMessageFields,\n        experimental_onFunctionCall,\n        messagesRef.current,\n        abortControllerRef.current,\n        generateId\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message, { options, functions, function_call, data } = {})=>{\n        if (!message.id) {\n            message.id = generateId();\n        }\n        const chatRequest = {\n            messages: messagesRef.current.concat(message),\n            options,\n            data,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest,\n        generateId\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ options, functions, function_call } = {})=>{\n        if (messagesRef.current.length === 0) return null;\n        const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n        if (lastMessage.role === \"assistant\") {\n            const chatRequest2 = {\n                messages: messagesRef.current.slice(0, -1),\n                options,\n                ...functions !== void 0 && {\n                    functions\n                },\n                ...function_call !== void 0 && {\n                    function_call\n                }\n            };\n            return triggerRequest(chatRequest2);\n        }\n        const chatRequest = {\n            messages: messagesRef.current,\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        mutate(messages2, false);\n        messagesRef.current = messages2;\n    }, [\n        mutate\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, options = {}, metadata)=>{\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        e.preventDefault();\n        if (!input) return;\n        append({\n            content: input,\n            role: \"user\",\n            createdAt: /* @__PURE__ */ new Date()\n        }, options);\n        setInput(\"\");\n    }, [\n        input,\n        append\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        messages: messages || [],\n        error,\n        append,\n        reload,\n        stop,\n        setMessages,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-completion.ts\n\n\nfunction useCompletion({ api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, onResponse, onFinish, onError } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"streamData\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController2 = new AbortController();\n            setAbortController(abortController2);\n            mutate(\"\", false);\n            const res = await fetch(api, {\n                method: \"POST\",\n                body: JSON.stringify({\n                    prompt,\n                    ...extraMetadataRef.current.body,\n                    ...options == null ? void 0 : options.body\n                }),\n                credentials: extraMetadataRef.current.credentials,\n                headers: {\n                    ...extraMetadataRef.current.headers,\n                    ...options == null ? void 0 : options.headers\n                },\n                signal: abortController2.signal\n            }).catch((err)=>{\n                throw err;\n            });\n            if (onResponse) {\n                try {\n                    await onResponse(res);\n                } catch (err) {\n                    throw err;\n                }\n            }\n            if (!res.ok) {\n                throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n            }\n            if (!res.body) {\n                throw new Error(\"The response body is empty.\");\n            }\n            let result = \"\";\n            const reader = res.body.getReader();\n            const isComplexMode = res.headers.get(COMPLEX_HEADER) === \"true\";\n            if (isComplexMode) {\n                for await (const { type, value } of readDataStream(reader, {\n                    isAborted: ()=>abortController2 === null\n                })){\n                    switch(type){\n                        case \"text\":\n                            {\n                                result += value;\n                                mutate(result, false);\n                                break;\n                            }\n                        case \"data\":\n                            {\n                                mutateStreamData([\n                                    ...streamData || [],\n                                    ...value || []\n                                ], false);\n                                break;\n                            }\n                    }\n                }\n            } else {\n                const decoder = createChunkDecoder();\n                while(true){\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n                    result += decoder(value);\n                    mutate(result, false);\n                    if (abortController2 === null) {\n                        reader.cancel();\n                        break;\n                    }\n                }\n            }\n            if (onFinish) {\n                onFinish(prompt, result);\n            }\n            setAbortController(null);\n            return result;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                setAbortController(null);\n                return null;\n            }\n            if (err instanceof Error) {\n                if (onError) {\n                    onError(err);\n                }\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        if (!input) return;\n        return complete(input);\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-assistant.ts\n\nfunction experimental_useAssistant({ api, threadId: threadIdParam, credentials, headers, body }) {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [threadId, setThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const handleInputChange = (event)=>{\n        setInput(event.target.value);\n    };\n    const submitMessage = async (event, requestOptions)=>{\n        var _a, _b;\n        (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n        if (input === \"\") {\n            return;\n        }\n        setStatus(\"in_progress\");\n        setMessages((messages2)=>[\n                ...messages2,\n                {\n                    id: \"\",\n                    role: \"user\",\n                    content: input\n                }\n            ]);\n        setInput(\"\");\n        const result = await fetch(api, {\n            method: \"POST\",\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            body: JSON.stringify({\n                ...body,\n                // always use user-provided threadId when available:\n                threadId: (_b = threadIdParam != null ? threadIdParam : threadId) != null ? _b : null,\n                message: input,\n                // optional request data:\n                data: requestOptions == null ? void 0 : requestOptions.data\n            })\n        });\n        if (result.body == null) {\n            throw new Error(\"The response body is empty.\");\n        }\n        try {\n            for await (const { type, value } of readDataStream(result.body.getReader())){\n                switch(type){\n                    case \"assistant_message\":\n                        {\n                            setMessages((messages2)=>[\n                                    ...messages2,\n                                    {\n                                        id: value.id,\n                                        role: value.role,\n                                        content: value.content[0].text.value\n                                    }\n                                ]);\n                            break;\n                        }\n                    case \"assistant_control_data\":\n                        {\n                            setThreadId(value.threadId);\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                lastMessage.id = value.messageId;\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    lastMessage\n                                ];\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            setError(value);\n                            break;\n                        }\n                }\n            }\n        } catch (error2) {\n            setError(error2);\n        }\n        setStatus(\"awaiting_message\");\n    };\n    return {\n        messages,\n        threadId,\n        input,\n        handleInputChange,\n        submitMessage,\n        status,\n        error\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O3FHQUVBLG9CQUFvQjtBQUNvRDtBQUMvQztBQUV6QixrQkFBa0I7QUFDaUM7QUFFbkQseUJBQXlCO0FBQ3pCLElBQUlPLGlCQUFpQjtJQUNuQkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUM3QixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFDQSxPQUFPO1lBQUVDLE1BQU07WUFBUUY7UUFBTTtJQUMvQjtBQUNGO0FBQ0EsSUFBSUcseUJBQXlCO0lBQzNCTixNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUlBLFNBQVMsUUFBUSxPQUFPQSxVQUFVLFlBQVksQ0FBRSxvQkFBbUJBLEtBQUksS0FBTSxPQUFPQSxNQUFNSSxhQUFhLEtBQUssWUFBWUosTUFBTUksYUFBYSxJQUFJLFFBQVEsQ0FBRSxXQUFVSixNQUFNSSxhQUFhLEtBQUssQ0FBRSxnQkFBZUosTUFBTUksYUFBYSxLQUFLLE9BQU9KLE1BQU1JLGFBQWEsQ0FBQ04sSUFBSSxLQUFLLFlBQVksT0FBT0UsTUFBTUksYUFBYSxDQUFDQyxTQUFTLEtBQUssVUFBVTtZQUN6VSxNQUFNLElBQUlKLE1BQ1I7UUFFSjtRQUNBLE9BQU87WUFDTEMsTUFBTTtZQUNORjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLElBQUlNLGlCQUFpQjtJQUNuQlQsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLENBQUNPLE1BQU1DLE9BQU8sQ0FBQ1IsUUFBUTtZQUN6QixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFDQSxPQUFPO1lBQUVDLE1BQU07WUFBUUY7UUFBTTtJQUMvQjtBQUNGO0FBQ0EsSUFBSVMsa0JBQWtCO0lBQ3BCWixNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElB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Q0EsSUFBSTtZQUNGLFdBQVcsTUFBTSxFQUFFQyxJQUFJLEVBQUVGLEtBQUssRUFBRSxJQUFJMkQsZUFDbEM2SCxPQUFPcEcsSUFBSSxDQUFDaUIsU0FBUyxJQUNwQjtnQkFDRCxPQUFRbkc7b0JBQ04sS0FBSzt3QkFBcUI7NEJBQ3hCK0osWUFBWSxDQUFDQyxZQUFjO3VDQUN0QkE7b0NBQ0g7d0NBQ0V2SixJQUFJWCxNQUFNVyxFQUFFO3dDQUNaQyxNQUFNWixNQUFNWSxJQUFJO3dDQUNoQkMsU0FBU2IsTUFBTWEsT0FBTyxDQUFDLEVBQUUsQ0FBQ0csSUFBSSxDQUFDaEIsS0FBSztvQ0FDdEM7aUNBQ0Q7NEJBQ0Q7d0JBQ0Y7b0JBQ0EsS0FBSzt3QkFBMEI7NEJBQzdCK0wsWUFBWS9MLE1BQU1rQixRQUFROzRCQUMxQitJLFlBQVksQ0FBQ0M7Z0NBQ1gsTUFBTUwsY0FBY0ssU0FBUyxDQUFDQSxVQUFVeEcsTUFBTSxHQUFHLEVBQUU7Z0NBQ25EbUcsWUFBWWxKLEVBQUUsR0FBR1gsTUFBTW1CLFNBQVM7Z0NBQ2hDLE9BQU87dUNBQUkrSSxVQUFVbkksS0FBSyxDQUFDLEdBQUdtSSxVQUFVeEcsTUFBTSxHQUFHO29DQUFJbUc7aUNBQVk7NEJBQ25FOzRCQUNBO3dCQUNGO29CQUNBLEtBQUs7d0JBQVM7NEJBQ1pQLFNBQVN0Sjs0QkFDVDt3QkFDRjtnQkFDRjtZQUNGO1FBQ0YsRUFBRSxPQUFPc00sUUFBUTtZQUNmaEQsU0FBU2dEO1FBQ1g7UUFDQUwsVUFBVTtJQUNaO0lBQ0EsT0FBTztRQUNMaEg7UUFDQS9EO1FBQ0FpSjtRQUNBSztRQUNBMkI7UUFDQUg7UUFDQTNDO0lBQ0Y7QUFDRjtBQUtFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXVsdGltb2RhbC1jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2FpL3JlYWN0L2Rpc3QvaW5kZXgubWpzPzJiZmEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbi8vIHJlYWN0L3VzZS1jaGF0LnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VJZCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHVzZVNXUiBmcm9tIFwic3dyXCI7XG5cbi8vIHNoYXJlZC91dGlscy50c1xuaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tIFwibmFub2lkL25vbi1zZWN1cmVcIjtcblxuLy8gc2hhcmVkL3N0cmVhbS1wYXJ0cy50c1xudmFyIHRleHRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjBcIixcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGV4dFwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIxXCIsXG4gIG5hbWU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJmdW5jdGlvbl9jYWxsXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlLmZ1bmN0aW9uX2NhbGwgPT0gbnVsbCB8fCAhKFwibmFtZVwiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8ICEoXCJhcmd1bWVudHNcIiBpbiB2YWx1ZS5mdW5jdGlvbl9jYWxsKSB8fCB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmdW5jdGlvbl9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmdW5jdGlvbl9jYWxsXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjJcIixcbiAgbmFtZTogXCJkYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJkYXRhXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZXJyb3JTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjNcIixcbiAgbmFtZTogXCJlcnJvclwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImVycm9yXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50TWVzc2FnZSA9IHtcbiAgY29kZTogXCI0XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB2YWx1ZSkgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImNvbnRlbnRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmlkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUuY29udGVudCkgfHwgIXZhbHVlLmNvbnRlbnQuZXZlcnkoXG4gICAgICAoaXRlbSkgPT4gaXRlbSAhPSBudWxsICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIGl0ZW0gJiYgaXRlbS50eXBlID09PSBcInRleHRcIiAmJiBcInRleHRcIiBpbiBpdGVtICYmIGl0ZW0udGV4dCAhPSBudWxsICYmIHR5cGVvZiBpdGVtLnRleHQgPT09IFwib2JqZWN0XCIgJiYgXCJ2YWx1ZVwiIGluIGl0ZW0udGV4dCAmJiB0eXBlb2YgaXRlbS50ZXh0LnZhbHVlID09PSBcInN0cmluZ1wiXG4gICAgKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIsIFwicm9sZVwiLCBhbmQgXCJjb250ZW50XCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRDb250cm9sRGF0YSA9IHtcbiAgY29kZTogXCI1XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0aHJlYWRJZFwiIGluIHZhbHVlKSB8fCAhKFwibWVzc2FnZUlkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50aHJlYWRJZCAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUubWVzc2FnZUlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRocmVhZElkXCIgYW5kIFwibWVzc2FnZUlkXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdGhyZWFkSWQ6IHZhbHVlLnRocmVhZElkLFxuICAgICAgICBtZXNzYWdlSWQ6IHZhbHVlLm1lc3NhZ2VJZFxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG52YXIgc3RyZWFtUGFydHMgPSBbXG4gIHRleHRTdHJlYW1QYXJ0LFxuICBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBkYXRhU3RyZWFtUGFydCxcbiAgZXJyb3JTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRNZXNzYWdlLFxuICBhc3Npc3RhbnRDb250cm9sRGF0YVxuXTtcbnZhciBzdHJlYW1QYXJ0c0J5Q29kZSA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0LmNvZGVdOiB0ZXh0U3RyZWFtUGFydCxcbiAgW2Z1bmN0aW9uQ2FsbFN0cmVhbVBhcnQuY29kZV06IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIFtkYXRhU3RyZWFtUGFydC5jb2RlXTogZGF0YVN0cmVhbVBhcnQsXG4gIFtlcnJvclN0cmVhbVBhcnQuY29kZV06IGVycm9yU3RyZWFtUGFydCxcbiAgW2Fzc2lzdGFudE1lc3NhZ2UuY29kZV06IGFzc2lzdGFudE1lc3NhZ2UsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YS5jb2RlXTogYXNzaXN0YW50Q29udHJvbERhdGFcbn07XG52YXIgU3RyZWFtU3RyaW5nUHJlZml4ZXMgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5uYW1lXTogdGV4dFN0cmVhbVBhcnQuY29kZSxcbiAgW2Z1bmN0aW9uQ2FsbFN0cmVhbVBhcnQubmFtZV06IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZXJyb3JTdHJlYW1QYXJ0Lm5hbWVdOiBlcnJvclN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudE1lc3NhZ2UubmFtZV06IGFzc2lzdGFudE1lc3NhZ2UuY29kZSxcbiAgW2Fzc2lzdGFudENvbnRyb2xEYXRhLm5hbWVdOiBhc3Npc3RhbnRDb250cm9sRGF0YS5jb2RlXG59O1xudmFyIHZhbGlkQ29kZXMgPSBzdHJlYW1QYXJ0cy5tYXAoKHBhcnQpID0+IHBhcnQuY29kZSk7XG52YXIgcGFyc2VTdHJlYW1QYXJ0ID0gKGxpbmUpID0+IHtcbiAgY29uc3QgZmlyc3RTZXBhcmF0b3JJbmRleCA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gIGlmIChmaXJzdFNlcGFyYXRvckluZGV4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBObyBzZXBhcmF0b3IgZm91bmQuXCIpO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IGxpbmUuc2xpY2UoMCwgZmlyc3RTZXBhcmF0b3JJbmRleCk7XG4gIGlmICghdmFsaWRDb2Rlcy5pbmNsdWRlcyhwcmVmaXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gSW52YWxpZCBjb2RlICR7cHJlZml4fS5gKTtcbiAgfVxuICBjb25zdCBjb2RlID0gcHJlZml4O1xuICBjb25zdCB0ZXh0VmFsdWUgPSBsaW5lLnNsaWNlKGZpcnN0U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgY29uc3QganNvblZhbHVlID0gSlNPTi5wYXJzZSh0ZXh0VmFsdWUpO1xuICByZXR1cm4gc3RyZWFtUGFydHNCeUNvZGVbY29kZV0ucGFyc2UoanNvblZhbHVlKTtcbn07XG5cbi8vIHNoYXJlZC91dGlscy50c1xudmFyIG5hbm9pZCA9IGN1c3RvbUFscGhhYmV0KFxuICBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIsXG4gIDdcbik7XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoY29tcGxleCkge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGlmICghY29tcGxleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihjaHVuaykge1xuICAgICAgaWYgKCFjaHVuaylcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KS5zcGxpdChcIlxcblwiKS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT09IFwiXCIpO1xuICAgIHJldHVybiBkZWNvZGVkLm1hcChwYXJzZVN0cmVhbVBhcnQpLmZpbHRlcihCb29sZWFuKTtcbiAgfTtcbn1cbnZhciBDT01QTEVYX0hFQURFUiA9IFwiWC1FeHBlcmltZW50YWwtU3RyZWFtLURhdGFcIjtcblxuLy8gc2hhcmVkL3JlYWQtZGF0YS1zdHJlYW0udHNcbnZhciBORVdMSU5FID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xuZnVuY3Rpb24gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpIHtcbiAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgY2h1bmtzLmxlbmd0aCA9IDA7XG4gIHJldHVybiBjb25jYXRlbmF0ZWRDaHVua3M7XG59XG5hc3luYyBmdW5jdGlvbiogcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gIGlzQWJvcnRlZFxufSA9IHt9KSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBjb25jYXRDaHVua3MoY2h1bmtzLCB0b3RhbExlbmd0aCk7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGNvbnN0IHN0cmVhbVBhcnRzMiA9IGRlY29kZXIuZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKS5tYXAocGFyc2VTdHJlYW1QYXJ0KTtcbiAgICBmb3IgKGNvbnN0IHN0cmVhbVBhcnQgb2Ygc3RyZWFtUGFydHMyKSB7XG4gICAgICB5aWVsZCBzdHJlYW1QYXJ0O1xuICAgIH1cbiAgICBpZiAoaXNBYm9ydGVkID09IG51bGwgPyB2b2lkIDAgOiBpc0Fib3J0ZWQoKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8vIHNoYXJlZC9wYXJzZS1jb21wbGV4LXJlc3BvbnNlLnRzXG5hc3luYyBmdW5jdGlvbiBwYXJzZUNvbXBsZXhSZXNwb25zZSh7XG4gIHJlYWRlcixcbiAgYWJvcnRDb250cm9sbGVyUmVmLFxuICB1cGRhdGUsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkID0gbmFub2lkLFxuICBnZXRDdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG59KSB7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IGdldEN1cnJlbnREYXRlKCk7XG4gIGNvbnN0IHByZWZpeE1hcCA9IHtcbiAgICBkYXRhOiBbXVxuICB9O1xuICBmb3IgYXdhaXQgKGNvbnN0IHsgdHlwZSwgdmFsdWUgfSBvZiByZWFkRGF0YVN0cmVhbShyZWFkZXIsIHtcbiAgICBpc0Fib3J0ZWQ6ICgpID0+IChhYm9ydENvbnRyb2xsZXJSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50KSA9PT0gbnVsbFxuICB9KSkge1xuICAgIGlmICh0eXBlID09PSBcInRleHRcIikge1xuICAgICAgaWYgKHByZWZpeE1hcFtcInRleHRcIl0pIHtcbiAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSA9IHtcbiAgICAgICAgICAuLi5wcmVmaXhNYXBbXCJ0ZXh0XCJdLFxuICAgICAgICAgIGNvbnRlbnQ6IChwcmVmaXhNYXBbXCJ0ZXh0XCJdLmNvbnRlbnQgfHwgXCJcIikgKyB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSA9IHtcbiAgICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogdmFsdWUsXG4gICAgICAgICAgY3JlYXRlZEF0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlID0gbnVsbDtcbiAgICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvbl9jYWxsXCIpIHtcbiAgICAgIHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl0gPSB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgIGZ1bmN0aW9uX2NhbGw6IHZhbHVlLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgIG5hbWU6IHZhbHVlLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgY3JlYXRlZEF0XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImRhdGFcIikge1xuICAgICAgcHJlZml4TWFwW1wiZGF0YVwiXS5wdXNoKC4uLnZhbHVlKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlID0gcHJlZml4TWFwW1widGV4dFwiXTtcbiAgICBjb25zdCBtZXJnZWQgPSBbZnVuY3Rpb25DYWxsTWVzc2FnZSwgcmVzcG9uc2VNZXNzYWdlXS5maWx0ZXIoXG4gICAgICBCb29sZWFuXG4gICAgKTtcbiAgICB1cGRhdGUobWVyZ2VkLCBbLi4ucHJlZml4TWFwW1wiZGF0YVwiXV0pO1xuICB9XG4gIG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaChwcmVmaXhNYXApO1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBbcHJlZml4TWFwLnRleHQsIHByZWZpeE1hcC5mdW5jdGlvbl9jYWxsXS5maWx0ZXIoXG4gICAgICBCb29sZWFuXG4gICAgKSxcbiAgICBkYXRhOiBwcmVmaXhNYXAuZGF0YVxuICB9O1xufVxuXG4vLyBzaGFyZWQvY2FsbC1hcGkudHNcbmFzeW5jIGZ1bmN0aW9uIGNhbGxBcGkoe1xuICBhcGksXG4gIG1lc3NhZ2VzLFxuICBib2R5LFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYWJvcnRDb250cm9sbGVyLFxuICBhcHBlbmRNZXNzYWdlLFxuICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUsXG4gIG9uUmVzcG9uc2UsXG4gIG9uVXBkYXRlLFxuICBvbkZpbmlzaCxcbiAgZ2VuZXJhdGVJZFxufSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBtZXNzYWdlcyxcbiAgICAgIC4uLmJvZHlcbiAgICB9KSxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIC4uLmhlYWRlcnNcbiAgICB9LFxuICAgIHNpZ25hbDogKF9hID0gYWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNpZ25hbCxcbiAgICBjcmVkZW50aWFsc1xuICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCk7XG4gICAgdGhyb3cgZXJyO1xuICB9KTtcbiAgaWYgKG9uUmVzcG9uc2UpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgb25SZXNwb25zZShyZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBhd2FpdCByZXNwb25zZS50ZXh0KCkgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICApO1xuICB9XG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgfVxuICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICBjb25zdCBpc0NvbXBsZXhNb2RlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoQ09NUExFWF9IRUFERVIpID09PSBcInRydWVcIjtcbiAgaWYgKGlzQ29tcGxleE1vZGUpIHtcbiAgICByZXR1cm4gYXdhaXQgcGFyc2VDb21wbGV4UmVzcG9uc2Uoe1xuICAgICAgcmVhZGVyLFxuICAgICAgYWJvcnRDb250cm9sbGVyUmVmOiBhYm9ydENvbnRyb2xsZXIgIT0gbnVsbCA/IHsgY3VycmVudDogYWJvcnRDb250cm9sbGVyKCkgfSA6IHZvaWQgMCxcbiAgICAgIHVwZGF0ZTogb25VcGRhdGUsXG4gICAgICBvbkZpbmlzaChwcmVmaXhNYXApIHtcbiAgICAgICAgaWYgKG9uRmluaXNoICYmIHByZWZpeE1hcC50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICBvbkZpbmlzaChwcmVmaXhNYXAudGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZUlkXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKGZhbHNlKTtcbiAgICBsZXQgc3RyZWFtZWRSZXNwb25zZSA9IFwiXCI7XG4gICAgY29uc3QgcmVwbHlJZCA9IGdlbmVyYXRlSWQoKTtcbiAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0ge1xuICAgICAgaWQ6IHJlcGx5SWQsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIlxuICAgIH07XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0cmVhbWVkUmVzcG9uc2UgKz0gZGVjb2RlKHZhbHVlKTtcbiAgICAgIGlmIChzdHJlYW1lZFJlc3BvbnNlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKSkge1xuICAgICAgICByZXNwb25zZU1lc3NhZ2VbXCJmdW5jdGlvbl9jYWxsXCJdID0gc3RyZWFtZWRSZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZVtcImNvbnRlbnRcIl0gPSBzdHJlYW1lZFJlc3BvbnNlO1xuICAgICAgfVxuICAgICAgYXBwZW5kTWVzc2FnZSh7IC4uLnJlc3BvbnNlTWVzc2FnZSB9KTtcbiAgICAgIGlmICgoYWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIoKSkgPT09IG51bGwpIHtcbiAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0cmVhbWVkUmVzcG9uc2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpKSB7XG4gICAgICBjb25zdCBwYXJzZWRGdW5jdGlvbkNhbGwgPSBKU09OLnBhcnNlKHN0cmVhbWVkUmVzcG9uc2UpLmZ1bmN0aW9uX2NhbGw7XG4gICAgICByZXNwb25zZU1lc3NhZ2VbXCJmdW5jdGlvbl9jYWxsXCJdID0gcGFyc2VkRnVuY3Rpb25DYWxsO1xuICAgICAgYXBwZW5kTWVzc2FnZSh7IC4uLnJlc3BvbnNlTWVzc2FnZSB9KTtcbiAgICB9XG4gICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICBvbkZpbmlzaChyZXNwb25zZU1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2VNZXNzYWdlO1xuICB9XG59XG5cbi8vIHNoYXJlZC9wcm9jZXNzLWNoYXQtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzQ2hhdFN0cmVhbSh7XG4gIGdldFN0cmVhbWVkUmVzcG9uc2U6IGdldFN0cmVhbWVkUmVzcG9uc2UyLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIHVwZGF0ZUNoYXRSZXF1ZXN0LFxuICBnZXRDdXJyZW50TWVzc2FnZXNcbn0pIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlID0gYXdhaXQgZ2V0U3RyZWFtZWRSZXNwb25zZTIoKTtcbiAgICBpZiAoXCJtZXNzYWdlc1wiIGluIG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UpIHtcbiAgICAgIGxldCBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gdm9pZCAwIHx8IHR5cGVvZiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IHRydWU7XG4gICAgICAgIGlmIChleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSBtZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICBnZXRDdXJyZW50TWVzc2FnZXMoKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWhhc0ZvbGxvd2luZ1Jlc3BvbnNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2U7XG4gICAgICBpZiAoc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gdm9pZCAwIHx8IHR5cGVvZiBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGxSZXNwb25zZSA9IGF3YWl0IGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgZnVuY3Rpb25DYWxsKTtcbiAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID09PSB2b2lkIDApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gcmVhY3QvdXNlLWNoYXQudHNcbnZhciBnZXRTdHJlYW1lZFJlc3BvbnNlID0gYXN5bmMgKGFwaSwgY2hhdFJlcXVlc3QsIG11dGF0ZSwgbXV0YXRlU3RyZWFtRGF0YSwgZXhpc3RpbmdEYXRhLCBleHRyYU1ldGFkYXRhUmVmLCBtZXNzYWdlc1JlZiwgYWJvcnRDb250cm9sbGVyUmVmLCBnZW5lcmF0ZUlkLCBvbkZpbmlzaCwgb25SZXNwb25zZSwgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcykgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCBwcmV2aW91c01lc3NhZ2VzID0gbWVzc2FnZXNSZWYuY3VycmVudDtcbiAgbXV0YXRlKGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCBmYWxzZSk7XG4gIGNvbnN0IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkID0gc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyA/IGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzIDogY2hhdFJlcXVlc3QubWVzc2FnZXMubWFwKCh7IHJvbGUsIGNvbnRlbnQsIG5hbWUsIGZ1bmN0aW9uX2NhbGwgfSkgPT4gKHtcbiAgICByb2xlLFxuICAgIGNvbnRlbnQsXG4gICAgLi4ubmFtZSAhPT0gdm9pZCAwICYmIHsgbmFtZSB9LFxuICAgIC4uLmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCAmJiB7XG4gICAgICBmdW5jdGlvbl9jYWxsXG4gICAgfVxuICB9KSk7XG4gIGlmICh0eXBlb2YgYXBpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgcmVwbHlJZCA9IGdlbmVyYXRlSWQoKTtcbiAgICBjb25zdCBjcmVhdGVkQXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0ge1xuICAgICAgaWQ6IHJlcGx5SWQsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIlxuICAgIH07XG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZFJvdyhwcm9taXNlKSB7XG4gICAgICBjb25zdCB7IGNvbnRlbnQsIHVpLCBuZXh0IH0gPSBhd2FpdCBwcm9taXNlO1xuICAgICAgcmVzcG9uc2VNZXNzYWdlW1wiY29udGVudFwiXSA9IGNvbnRlbnQ7XG4gICAgICByZXNwb25zZU1lc3NhZ2VbXCJ1aVwiXSA9IGF3YWl0IHVpO1xuICAgICAgbXV0YXRlKFsuLi5jaGF0UmVxdWVzdC5tZXNzYWdlcywgeyAuLi5yZXNwb25zZU1lc3NhZ2UgfV0sIGZhbHNlKTtcbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGF3YWl0IHJlYWRSb3cobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9taXNlID0gYXBpKHtcbiAgICAgICAgbWVzc2FnZXM6IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkLFxuICAgICAgICBkYXRhOiBjaGF0UmVxdWVzdC5kYXRhXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IHJlYWRSb3cocHJvbWlzZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocmVzcG9uc2VNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZTtcbiAgfVxuICByZXR1cm4gYXdhaXQgY2FsbEFwaSh7XG4gICAgYXBpLFxuICAgIG1lc3NhZ2VzOiBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCxcbiAgICBib2R5OiB7XG4gICAgICBkYXRhOiBjaGF0UmVxdWVzdC5kYXRhLFxuICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmJvZHksXG4gICAgICAuLi4oX2EgPSBjaGF0UmVxdWVzdC5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2EuYm9keSxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0LmZ1bmN0aW9ucyAhPT0gdm9pZCAwICYmIHtcbiAgICAgICAgZnVuY3Rpb25zOiBjaGF0UmVxdWVzdC5mdW5jdGlvbnNcbiAgICAgIH0sXG4gICAgICAuLi5jaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDAgJiYge1xuICAgICAgICBmdW5jdGlvbl9jYWxsOiBjaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsXG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5oZWFkZXJzLFxuICAgICAgLi4uKF9iID0gY2hhdFJlcXVlc3Qub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmhlYWRlcnNcbiAgICB9LFxuICAgIGFib3J0Q29udHJvbGxlcjogKCkgPT4gYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQsXG4gICAgYXBwZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCBtZXNzYWdlXSwgZmFsc2UpO1xuICAgIH0sXG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCkge1xuICAgICAgbXV0YXRlKHByZXZpb3VzTWVzc2FnZXMsIGZhbHNlKTtcbiAgICB9LFxuICAgIG9uUmVzcG9uc2UsXG4gICAgb25VcGRhdGUobWVyZ2VkLCBkYXRhKSB7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCAuLi5tZXJnZWRdLCBmYWxzZSk7XG4gICAgICBtdXRhdGVTdHJlYW1EYXRhKFsuLi5leGlzdGluZ0RhdGEgfHwgW10sIC4uLmRhdGEgfHwgW11dLCBmYWxzZSk7XG4gICAgfSxcbiAgICBvbkZpbmlzaCxcbiAgICBnZW5lcmF0ZUlkXG4gIH0pO1xufTtcbmZ1bmN0aW9uIHVzZUNoYXQoe1xuICBhcGkgPSBcIi9hcGkvY2hhdFwiLFxuICBpZCxcbiAgaW5pdGlhbE1lc3NhZ2VzLFxuICBpbml0aWFsSW5wdXQgPSBcIlwiLFxuICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgZ2VuZXJhdGVJZCA9IG5hbm9pZFxufSA9IHt9KSB7XG4gIGNvbnN0IGhvb2tJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IGNoYXRJZCA9IGlkIHx8IGhvb2tJZDtcbiAgY29uc3QgW2luaXRpYWxNZXNzYWdlc0ZhbGxiYWNrXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgeyBkYXRhOiBtZXNzYWdlcywgbXV0YXRlIH0gPSB1c2VTV1IoW2FwaSwgY2hhdElkXSwgbnVsbCwge1xuICAgIGZhbGxiYWNrRGF0YTogaW5pdGlhbE1lc3NhZ2VzICE9IG51bGwgPyBpbml0aWFsTWVzc2FnZXMgOiBpbml0aWFsTWVzc2FnZXNGYWxsYmFja1xuICB9KTtcbiAgY29uc3QgeyBkYXRhOiBpc0xvYWRpbmcgPSBmYWxzZSwgbXV0YXRlOiBtdXRhdGVMb2FkaW5nIH0gPSB1c2VTV1IoXG4gICAgW2NoYXRJZCwgXCJsb2FkaW5nXCJdLFxuICAgIG51bGxcbiAgKTtcbiAgY29uc3QgeyBkYXRhOiBzdHJlYW1EYXRhLCBtdXRhdGU6IG11dGF0ZVN0cmVhbURhdGEgfSA9IHVzZVNXUihbY2hhdElkLCBcInN0cmVhbURhdGFcIl0sIG51bGwpO1xuICBjb25zdCBtZXNzYWdlc1JlZiA9IHVzZVJlZihtZXNzYWdlcyB8fCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbWVzc2FnZXNSZWYuY3VycmVudCA9IG1lc3NhZ2VzIHx8IFtdO1xuICB9LCBbbWVzc2FnZXNdKTtcbiAgY29uc3QgYWJvcnRDb250cm9sbGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBleHRyYU1ldGFkYXRhUmVmID0gdXNlUmVmKHtcbiAgICBjcmVkZW50aWFscyxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHlcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50ID0ge1xuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sIFtjcmVkZW50aWFscywgaGVhZGVycywgYm9keV0pO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKCk7XG4gIGNvbnN0IHRyaWdnZXJSZXF1ZXN0ID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGNoYXRSZXF1ZXN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBtdXRhdGVMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcih2b2lkIDApO1xuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gYWJvcnRDb250cm9sbGVyO1xuICAgICAgICBhd2FpdCBwcm9jZXNzQ2hhdFN0cmVhbSh7XG4gICAgICAgICAgZ2V0U3RyZWFtZWRSZXNwb25zZTogKCkgPT4gZ2V0U3RyZWFtZWRSZXNwb25zZShcbiAgICAgICAgICAgIGFwaSxcbiAgICAgICAgICAgIGNoYXRSZXF1ZXN0LFxuICAgICAgICAgICAgbXV0YXRlLFxuICAgICAgICAgICAgbXV0YXRlU3RyZWFtRGF0YSxcbiAgICAgICAgICAgIHN0cmVhbURhdGEsXG4gICAgICAgICAgICBleHRyYU1ldGFkYXRhUmVmLFxuICAgICAgICAgICAgbWVzc2FnZXNSZWYsXG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gICAgICAgICAgICBnZW5lcmF0ZUlkLFxuICAgICAgICAgICAgb25GaW5pc2gsXG4gICAgICAgICAgICBvblJlc3BvbnNlLFxuICAgICAgICAgICAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkc1xuICAgICAgICAgICksXG4gICAgICAgICAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0OiAoY2hhdFJlcXVlc3RQYXJhbSkgPT4ge1xuICAgICAgICAgICAgY2hhdFJlcXVlc3QgPSBjaGF0UmVxdWVzdFBhcmFtO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0Q3VycmVudE1lc3NhZ2VzOiAoKSA9PiBtZXNzYWdlc1JlZi5jdXJyZW50XG4gICAgICAgIH0pO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25FcnJvciAmJiBlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRFcnJvcihlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBtdXRhdGUsXG4gICAgICBtdXRhdGVMb2FkaW5nLFxuICAgICAgYXBpLFxuICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgIG9uUmVzcG9uc2UsXG4gICAgICBvbkZpbmlzaCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBzZXRFcnJvcixcbiAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgICBzdHJlYW1EYXRhLFxuICAgICAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgICAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQsXG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCxcbiAgICAgIGdlbmVyYXRlSWRcbiAgICBdXG4gICk7XG4gIGNvbnN0IGFwcGVuZCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChtZXNzYWdlLCB7IG9wdGlvbnMsIGZ1bmN0aW9ucywgZnVuY3Rpb25fY2FsbCwgZGF0YSB9ID0ge30pID0+IHtcbiAgICAgIGlmICghbWVzc2FnZS5pZCkge1xuICAgICAgICBtZXNzYWdlLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhdFJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LmNvbmNhdChtZXNzYWdlKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgLi4uZnVuY3Rpb25zICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbnMgfSxcbiAgICAgICAgLi4uZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25fY2FsbCB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0KTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdCwgZ2VuZXJhdGVJZF1cbiAgKTtcbiAgY29uc3QgcmVsb2FkID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHsgb3B0aW9ucywgZnVuY3Rpb25zLCBmdW5jdGlvbl9jYWxsIH0gPSB7fSkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2VzUmVmLmN1cnJlbnQubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNSZWYuY3VycmVudFttZXNzYWdlc1JlZi5jdXJyZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3RNZXNzYWdlLnJvbGUgPT09IFwiYXNzaXN0YW50XCIpIHtcbiAgICAgICAgY29uc3QgY2hhdFJlcXVlc3QyID0ge1xuICAgICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LnNsaWNlKDAsIC0xKSxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIC4uLmZ1bmN0aW9ucyAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25zIH0sXG4gICAgICAgICAgLi4uZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25fY2FsbCB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdDIpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhdFJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICAuLi5mdW5jdGlvbnMgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9ucyB9LFxuICAgICAgICAuLi5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbl9jYWxsIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0XVxuICApO1xuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCkge1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQuYWJvcnQoKTtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3Qgc2V0TWVzc2FnZXMgPSB1c2VDYWxsYmFjayhcbiAgICAobWVzc2FnZXMyKSA9PiB7XG4gICAgICBtdXRhdGUobWVzc2FnZXMyLCBmYWxzZSk7XG4gICAgICBtZXNzYWdlc1JlZi5jdXJyZW50ID0gbWVzc2FnZXMyO1xuICAgIH0sXG4gICAgW211dGF0ZV1cbiAgKTtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZShpbml0aWFsSW5wdXQpO1xuICBjb25zdCBoYW5kbGVTdWJtaXQgPSB1c2VDYWxsYmFjayhcbiAgICAoZSwgb3B0aW9ucyA9IHt9LCBtZXRhZGF0YSkgPT4ge1xuICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQsXG4gICAgICAgICAgLi4ubWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICghaW5wdXQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGFwcGVuZChcbiAgICAgICAge1xuICAgICAgICAgIGNvbnRlbnQ6IGlucHV0LFxuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNyZWF0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICAgIHNldElucHV0KFwiXCIpO1xuICAgIH0sXG4gICAgW2lucHV0LCBhcHBlbmRdXG4gICk7XG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGUpID0+IHtcbiAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IG1lc3NhZ2VzIHx8IFtdLFxuICAgIGVycm9yLFxuICAgIGFwcGVuZCxcbiAgICByZWxvYWQsXG4gICAgc3RvcCxcbiAgICBzZXRNZXNzYWdlcyxcbiAgICBpbnB1dCxcbiAgICBzZXRJbnB1dCxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBoYW5kbGVTdWJtaXQsXG4gICAgaXNMb2FkaW5nLFxuICAgIGRhdGE6IHN0cmVhbURhdGFcbiAgfTtcbn1cblxuLy8gcmVhY3QvdXNlLWNvbXBsZXRpb24udHNcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMiwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIsIHVzZUlkIGFzIHVzZUlkMiwgdXNlUmVmIGFzIHVzZVJlZjIsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMiB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHVzZVNXUjIgZnJvbSBcInN3clwiO1xuZnVuY3Rpb24gdXNlQ29tcGxldGlvbih7XG4gIGFwaSA9IFwiL2FwaS9jb21wbGV0aW9uXCIsXG4gIGlkLFxuICBpbml0aWFsQ29tcGxldGlvbiA9IFwiXCIsXG4gIGluaXRpYWxJbnB1dCA9IFwiXCIsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvclxufSA9IHt9KSB7XG4gIGNvbnN0IGhvb2tJZCA9IHVzZUlkMigpO1xuICBjb25zdCBjb21wbGV0aW9uSWQgPSBpZCB8fCBob29rSWQ7XG4gIGNvbnN0IHsgZGF0YSwgbXV0YXRlIH0gPSB1c2VTV1IyKFthcGksIGNvbXBsZXRpb25JZF0sIG51bGwsIHtcbiAgICBmYWxsYmFja0RhdGE6IGluaXRpYWxDb21wbGV0aW9uXG4gIH0pO1xuICBjb25zdCB7IGRhdGE6IGlzTG9hZGluZyA9IGZhbHNlLCBtdXRhdGU6IG11dGF0ZUxvYWRpbmcgfSA9IHVzZVNXUjIoXG4gICAgW2NvbXBsZXRpb25JZCwgXCJsb2FkaW5nXCJdLFxuICAgIG51bGxcbiAgKTtcbiAgY29uc3QgeyBkYXRhOiBzdHJlYW1EYXRhLCBtdXRhdGU6IG11dGF0ZVN0cmVhbURhdGEgfSA9IHVzZVNXUjIoW2NvbXBsZXRpb25JZCwgXCJzdHJlYW1EYXRhXCJdLCBudWxsKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTIodm9pZCAwKTtcbiAgY29uc3QgY29tcGxldGlvbiA9IGRhdGE7XG4gIGNvbnN0IFthYm9ydENvbnRyb2xsZXIsIHNldEFib3J0Q29udHJvbGxlcl0gPSB1c2VTdGF0ZTIobnVsbCk7XG4gIGNvbnN0IGV4dHJhTWV0YWRhdGFSZWYgPSB1c2VSZWYyKHtcbiAgICBjcmVkZW50aWFscyxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHlcbiAgfSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LCBbY3JlZGVudGlhbHMsIGhlYWRlcnMsIGJvZHldKTtcbiAgY29uc3QgdHJpZ2dlclJlcXVlc3QgPSB1c2VDYWxsYmFjazIoXG4gICAgYXN5bmMgKHByb21wdCwgb3B0aW9ucykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyMiA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgc2V0QWJvcnRDb250cm9sbGVyKGFib3J0Q29udHJvbGxlcjIpO1xuICAgICAgICBtdXRhdGUoXCJcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgICAgICAgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5ib2R5XG4gICAgICAgICAgfSksXG4gICAgICAgICAgY3JlZGVudGlhbHM6IGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5jcmVkZW50aWFscyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuaGVhZGVycyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVyc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIyLnNpZ25hbFxuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9uUmVzcG9uc2UpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgb25SZXNwb25zZShyZXMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGF3YWl0IHJlcy50ZXh0KCkgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzLmJvZHkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHJlcy5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgICBjb25zdCBpc0NvbXBsZXhNb2RlID0gcmVzLmhlYWRlcnMuZ2V0KENPTVBMRVhfSEVBREVSKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIGlmIChpc0NvbXBsZXhNb2RlKSB7XG4gICAgICAgICAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gICAgICAgICAgICBpc0Fib3J0ZWQ6ICgpID0+IGFib3J0Q29udHJvbGxlcjIgPT09IG51bGxcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICAgICAgICAgICAgbXV0YXRlKHJlc3VsdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICBtdXRhdGVTdHJlYW1EYXRhKFxuICAgICAgICAgICAgICAgICAgWy4uLnN0cmVhbURhdGEgfHwgW10sIC4uLnZhbHVlIHx8IFtdXSxcbiAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkZWNvZGVyID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBkZWNvZGVyKHZhbHVlKTtcbiAgICAgICAgICAgIG11dGF0ZShyZXN1bHQsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgICAgIG9uRmluaXNoKHByb21wdCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRFcnJvcihlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBtdXRhdGUsXG4gICAgICBtdXRhdGVMb2FkaW5nLFxuICAgICAgYXBpLFxuICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcixcbiAgICAgIG9uUmVzcG9uc2UsXG4gICAgICBvbkZpbmlzaCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBzZXRFcnJvclxuICAgIF1cbiAgKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrMigoKSA9PiB7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlcikge1xuICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgfVxuICB9LCBbYWJvcnRDb250cm9sbGVyXSk7XG4gIGNvbnN0IHNldENvbXBsZXRpb24gPSB1c2VDYWxsYmFjazIoXG4gICAgKGNvbXBsZXRpb24yKSA9PiB7XG4gICAgICBtdXRhdGUoY29tcGxldGlvbjIsIGZhbHNlKTtcbiAgICB9LFxuICAgIFttdXRhdGVdXG4gICk7XG4gIGNvbnN0IGNvbXBsZXRlID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jIChwcm9tcHQsIG9wdGlvbnMpID0+IHtcbiAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChwcm9tcHQsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0XVxuICApO1xuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlMihpbml0aWFsSW5wdXQpO1xuICBjb25zdCBoYW5kbGVTdWJtaXQgPSB1c2VDYWxsYmFjazIoXG4gICAgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICghaW5wdXQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHJldHVybiBjb21wbGV0ZShpbnB1dCk7XG4gICAgfSxcbiAgICBbaW5wdXQsIGNvbXBsZXRlXVxuICApO1xuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChlKSA9PiB7XG4gICAgc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGNvbXBsZXRpb24sXG4gICAgY29tcGxldGUsXG4gICAgZXJyb3IsXG4gICAgc2V0Q29tcGxldGlvbixcbiAgICBzdG9wLFxuICAgIGlucHV0LFxuICAgIHNldElucHV0LFxuICAgIGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgIGhhbmRsZVN1Ym1pdCxcbiAgICBpc0xvYWRpbmcsXG4gICAgZGF0YTogc3RyZWFtRGF0YVxuICB9O1xufVxuXG4vLyByZWFjdC91c2UtYXNzaXN0YW50LnRzXG5pbXBvcnQgeyB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTMgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIGV4cGVyaW1lbnRhbF91c2VBc3Npc3RhbnQoe1xuICBhcGksXG4gIHRocmVhZElkOiB0aHJlYWRJZFBhcmFtLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keVxufSkge1xuICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlMyhbXSk7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUzKFwiXCIpO1xuICBjb25zdCBbdGhyZWFkSWQsIHNldFRocmVhZElkXSA9IHVzZVN0YXRlMyh2b2lkIDApO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gdXNlU3RhdGUzKFwiYXdhaXRpbmdfbWVzc2FnZVwiKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTModm9pZCAwKTtcbiAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICBzZXRJbnB1dChldmVudC50YXJnZXQudmFsdWUpO1xuICB9O1xuICBjb25zdCBzdWJtaXRNZXNzYWdlID0gYXN5bmMgKGV2ZW50LCByZXF1ZXN0T3B0aW9ucykgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgKF9hID0gZXZlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGV2ZW50LnByZXZlbnREZWZhdWx0KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChldmVudCk7XG4gICAgaWYgKGlucHV0ID09PSBcIlwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldFN0YXR1cyhcImluX3Byb2dyZXNzXCIpO1xuICAgIHNldE1lc3NhZ2VzKChtZXNzYWdlczIpID0+IFtcbiAgICAgIC4uLm1lc3NhZ2VzMixcbiAgICAgIHsgaWQ6IFwiXCIsIHJvbGU6IFwidXNlclwiLCBjb250ZW50OiBpbnB1dCB9XG4gICAgXSk7XG4gICAgc2V0SW5wdXQoXCJcIik7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLCAuLi5oZWFkZXJzIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIC4uLmJvZHksXG4gICAgICAgIC8vIGFsd2F5cyB1c2UgdXNlci1wcm92aWRlZCB0aHJlYWRJZCB3aGVuIGF2YWlsYWJsZTpcbiAgICAgICAgdGhyZWFkSWQ6IChfYiA9IHRocmVhZElkUGFyYW0gIT0gbnVsbCA/IHRocmVhZElkUGFyYW0gOiB0aHJlYWRJZCkgIT0gbnVsbCA/IF9iIDogbnVsbCxcbiAgICAgICAgbWVzc2FnZTogaW5wdXQsXG4gICAgICAgIC8vIG9wdGlvbmFsIHJlcXVlc3QgZGF0YTpcbiAgICAgICAgZGF0YTogcmVxdWVzdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHJlcXVlc3RPcHRpb25zLmRhdGFcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5ib2R5ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgeyB0eXBlLCB2YWx1ZSB9IG9mIHJlYWREYXRhU3RyZWFtKFxuICAgICAgICByZXN1bHQuYm9keS5nZXRSZWFkZXIoKVxuICAgICAgKSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiYXNzaXN0YW50X21lc3NhZ2VcIjoge1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMoKG1lc3NhZ2VzMikgPT4gW1xuICAgICAgICAgICAgICAuLi5tZXNzYWdlczIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWQsXG4gICAgICAgICAgICAgICAgcm9sZTogdmFsdWUucm9sZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50WzBdLnRleHQudmFsdWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIjoge1xuICAgICAgICAgICAgc2V0VGhyZWFkSWQodmFsdWUudGhyZWFkSWQpO1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMoKG1lc3NhZ2VzMikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzMlttZXNzYWdlczIubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGxhc3RNZXNzYWdlLmlkID0gdmFsdWUubWVzc2FnZUlkO1xuICAgICAgICAgICAgICByZXR1cm4gWy4uLm1lc3NhZ2VzMi5zbGljZSgwLCBtZXNzYWdlczIubGVuZ3RoIC0gMSksIGxhc3RNZXNzYWdlXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgICBzZXRFcnJvcih2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIHNldEVycm9yKGVycm9yMik7XG4gICAgfVxuICAgIHNldFN0YXR1cyhcImF3YWl0aW5nX21lc3NhZ2VcIik7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXMsXG4gICAgdGhyZWFkSWQsXG4gICAgaW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgc3VibWl0TWVzc2FnZSxcbiAgICBzdGF0dXMsXG4gICAgZXJyb3JcbiAgfTtcbn1cbmV4cG9ydCB7XG4gIGV4cGVyaW1lbnRhbF91c2VBc3Npc3RhbnQsXG4gIHVzZUNoYXQsXG4gIHVzZUNvbXBsZXRpb25cbn07XG4iXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VJZCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlU1dSIiwiY3VzdG9tQWxwaGFiZXQiLCJ0ZXh0U3RyZWFtUGFydCIsImNvZGUiLCJuYW1lIiwicGFyc2UiLCJ2YWx1ZSIsIkVycm9yIiwidHlwZSIsImZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQiLCJmdW5jdGlvbl9jYWxsIiwiYXJndW1lbnRzIiwiZGF0YVN0cmVhbVBhcnQiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvclN0cmVhbVBhcnQiLCJhc3Npc3RhbnRNZXNzYWdlIiwiaWQiLCJyb2xlIiwiY29udGVudCIsImV2ZXJ5IiwiaXRlbSIsInRleHQiLCJhc3Npc3RhbnRDb250cm9sRGF0YSIsInRocmVhZElkIiwibWVzc2FnZUlkIiwic3RyZWFtUGFydHMiLCJzdHJlYW1QYXJ0c0J5Q29kZSIsIlN0cmVhbVN0cmluZ1ByZWZpeGVzIiwidmFsaWRDb2RlcyIsIm1hcCIsInBhcnQiLCJwYXJzZVN0cmVhbVBhcnQiLCJsaW5lIiwiZmlyc3RTZXBhcmF0b3JJbmRleCIsImluZGV4T2YiLCJwcmVmaXgiLCJzbGljZSIsImluY2x1ZGVzIiwidGV4dFZhbHVlIiwianNvblZhbHVlIiwiSlNPTiIsIm5hbm9pZCIsImNyZWF0ZUNodW5rRGVjb2RlciIsImNvbXBsZXgiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJjaHVuayIsImRlY29kZSIsInN0cmVhbSIsImRlY29kZWQiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJDT01QTEVYX0hFQURFUiIsIk5FV0xJTkUiLCJjaGFyQ29kZUF0IiwiY29uY2F0Q2h1bmtzIiwiY2h1bmtzIiwidG90YWxMZW5ndGgiLCJjb25jYXRlbmF0ZWRDaHVua3MiLCJVaW50OEFycmF5Iiwib2Zmc2V0Iiwic2V0IiwibGVuZ3RoIiwicmVhZERhdGFTdHJlYW0iLCJyZWFkZXIiLCJpc0Fib3J0ZWQiLCJyZWFkIiwicHVzaCIsInN0cmVhbVBhcnRzMiIsInN0cmVhbVBhcnQiLCJjYW5jZWwiLCJwYXJzZUNvbXBsZXhSZXNwb25zZSIsImFib3J0Q29udHJvbGxlclJlZiIsInVwZGF0ZSIsIm9uRmluaXNoIiwiZ2VuZXJhdGVJZCIsImdldEN1cnJlbnREYXRlIiwiRGF0ZSIsImNyZWF0ZWRBdCIsInByZWZpeE1hcCIsImRhdGEiLCJjdXJyZW50IiwiZnVuY3Rpb25DYWxsTWVzc2FnZSIsInJlc3BvbnNlTWVzc2FnZSIsIm1lcmdlZCIsIm1lc3NhZ2VzIiwiY2FsbEFwaSIsImFwaSIsImJvZHkiLCJjcmVkZW50aWFscyIsImhlYWRlcnMiLCJhYm9ydENvbnRyb2xsZXIiLCJhcHBlbmRNZXNzYWdlIiwicmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlIiwib25SZXNwb25zZSIsIm9uVXBkYXRlIiwiX2EiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwic3RyaW5naWZ5Iiwic2lnbmFsIiwiY2F0Y2giLCJlcnIiLCJvayIsImdldFJlYWRlciIsImlzQ29tcGxleE1vZGUiLCJnZXQiLCJzdHJlYW1lZFJlc3BvbnNlIiwicmVwbHlJZCIsImRvbmUiLCJzdGFydHNXaXRoIiwicGFyc2VkRnVuY3Rpb25DYWxsIiwicHJvY2Vzc0NoYXRTdHJlYW0iLCJnZXRTdHJlYW1lZFJlc3BvbnNlIiwiZ2V0U3RyZWFtZWRSZXNwb25zZTIiLCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwiLCJ1cGRhdGVDaGF0UmVxdWVzdCIsImdldEN1cnJlbnRNZXNzYWdlcyIsIm1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UiLCJoYXNGb2xsb3dpbmdSZXNwb25zZSIsIm1lc3NhZ2UiLCJmdW5jdGlvbkNhbGwiLCJmdW5jdGlvbkNhbGxSZXNwb25zZSIsInN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlIiwiY2hhdFJlcXVlc3QiLCJtdXRhdGUiLCJtdXRhdGVTdHJlYW1EYXRhIiwiZXhpc3RpbmdEYXRhIiwiZXh0cmFNZXRhZGF0YVJlZiIsIm1lc3NhZ2VzUmVmIiwic2VuZEV4dHJhTWVzc2FnZUZpZWxkcyIsIl9iIiwicHJldmlvdXNNZXNzYWdlcyIsImNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkIiwicmVhZFJvdyIsInByb21pc2UiLCJ1aSIsIm5leHQiLCJlIiwib3B0aW9ucyIsImZ1bmN0aW9ucyIsInVzZUNoYXQiLCJpbml0aWFsTWVzc2FnZXMiLCJpbml0aWFsSW5wdXQiLCJvbkVycm9yIiwiaG9va0lkIiwiY2hhdElkIiwiaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2siLCJmYWxsYmFja0RhdGEiLCJpc0xvYWRpbmciLCJtdXRhdGVMb2FkaW5nIiwic3RyZWFtRGF0YSIsImVycm9yIiwic2V0RXJyb3IiLCJ0cmlnZ2VyUmVxdWVzdCIsIkFib3J0Q29udHJvbGxlciIsImNoYXRSZXF1ZXN0UGFyYW0iLCJhcHBlbmQiLCJjb25jYXQiLCJyZWxvYWQiLCJsYXN0TWVzc2FnZSIsImNoYXRSZXF1ZXN0MiIsInN0b3AiLCJhYm9ydCIsInNldE1lc3NhZ2VzIiwibWVzc2FnZXMyIiwiaW5wdXQiLCJzZXRJbnB1dCIsImhhbmRsZVN1Ym1pdCIsIm1ldGFkYXRhIiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVJbnB1dENoYW5nZSIsInRhcmdldCIsInVzZUNhbGxiYWNrMiIsInVzZUVmZmVjdDIiLCJ1c2VJZDIiLCJ1c2VSZWYyIiwidXNlU3RhdGUyIiwidXNlU1dSMiIsInVzZUNvbXBsZXRpb24iLCJpbml0aWFsQ29tcGxldGlvbiIsImNvbXBsZXRpb25JZCIsImNvbXBsZXRpb24iLCJzZXRBYm9ydENvbnRyb2xsZXIiLCJwcm9tcHQiLCJhYm9ydENvbnRyb2xsZXIyIiwicmVzIiwicmVzdWx0Iiwic2V0Q29tcGxldGlvbiIsImNvbXBsZXRpb24yIiwiY29tcGxldGUiLCJ1c2VTdGF0ZTMiLCJleHBlcmltZW50YWxfdXNlQXNzaXN0YW50IiwidGhyZWFkSWRQYXJhbSIsInNldFRocmVhZElkIiwic3RhdHVzIiwic2V0U3RhdHVzIiwiZXZlbnQiLCJzdWJtaXRNZXNzYWdlIiwicmVxdWVzdE9wdGlvbnMiLCJjYWxsIiwiZXJyb3IyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ })

};
;